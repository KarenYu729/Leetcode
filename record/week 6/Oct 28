week 6
Oct 28




"""
--------------------------------------题目分割线----------------------------------------------
"""
343. Integer Break <medium>
输入：
int
输出：
int

class Solution(object):
    def integerBreak(self, n):
        """
        :type n: int
        :rtype: int
        """
        dp = [0] * (n + 1)
        dp[1] = 1
        for i in range(2, n + 1):
            for j in range(1, i):
                dp[i] = max(dp[i], max(j * dp[i - j], j * (i - j)))
        return dp[n]
        

效果：
Runtime: 23 ms, faster than 84.96% of Python online submissions for Integer Break.
Memory Usage: 13.7 MB, less than 5.94% of Python online submissions for Integer Break.

reference：
https://leetcode.com/problems/integer-break/discuss/2404837/Python-Easy-Solution-(faster-than-87)




"""
--------------------------------------题目分割线----------------------------------------------
"""
127. Word Ladder <hard>
输入：
str
str
str[]
输出：
int

class Solution(object):
    def ladderLength(self, beginWord, endWord, wordList):
        """
        :type beginWord: str
        :type endWord: str
        :type wordList: List[str]
        :rtype: int
        """
        #Check if endWord exists in wordList
        if endWord not in wordList:
            return 0
        
        #Initialize queue and res
        q = collections.deque()
        q.append(beginWord)
        res = 0
        #Cuz TC for removal of elem from list is O(n) while for set, it is O(1)
        wordList = set(wordList)
        
        #BFS
        while q:
            #Result incremented for every level
            res += 1
            qsize = len(q)
            #Iterate over all elems in current level
            for k in range(qsize):
                word = q.popleft()
                #If word is result
                if word == endWord:
                    return res
                #If word is not result, then iterate over its length and find its neighbours
                for i in range(len(word)):
                    start = ord('a')
                    for j in range(26):
                        temp = word[:i] + chr(start+j) + word[i+1:]
                        #If neighbour is valid
                        if (temp in wordList):
                            q.append(temp)
                            wordList.remove(temp)
        return 0
        

效果：
Runtime: 1189 ms, faster than 19.26% of Python online submissions for Word Ladder.
Memory Usage: 14.5 MB, less than 82.73% of Python online submissions for Word Ladder.

reference:
https://leetcode.com/problems/word-ladder/discuss/2435121/Simple-Python-BFS-SC-94

函数说明：




"""
--------------------------------------题目分割线----------------------------------------------
"""

输入：

输出：



        

效果：







