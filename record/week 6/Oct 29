week 6
Oct 29




"""
--------------------------------------题目分割线----------------------------------------------
"""
994. Rotting Oranges <medium>
输入：
int[int[]]
输出：
int

class Solution(object):
    def orangesRotting(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        rotOrange = collections.deque()
        need_visit = set()
        time=0
        
        m, n = len(grid), len(grid[0])
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    need_visit.add((i,j))
                elif grid[i][j] == 2:
                    rotOrange.append((i,j))
        
        dirs = ((0,1), (0,-1), (1,0), (-1,0))
        while rotOrange and need_visit:
            size = len(rotOrange)
            while size>0:
                i,j = rotOrange.popleft()
                for x,y in dirs:
                    nexti, nextj = i+x, j+y
                    if (nexti, nextj) in need_visit:
                        need_visit.remove((nexti, nextj))
                        rotOrange.append((nexti, nextj))
                size-=1
            time+=1
        
        return -1 if len(need_visit)>0 else time
        

效果：
Runtime: 80 ms, faster than 38.97% of Python online submissions for Rotting Oranges.
Memory Usage: 13.4 MB, less than 73.05% of Python online submissions for Rotting Oranges.

reference:
https://leetcode.com/problems/rotting-oranges/discuss/1546489/Python-BFS%3A-Easy-to-understand-with-Explanation




"""
--------------------------------------题目分割线----------------------------------------------
"""
863. All Nodes Distance K in Binary Tree <Medium>
输入：
TreeNode
TreeNode
int
输出：
int[]

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def distanceK(self, root, target, k):
        """
        :type root: TreeNode
        :type target: TreeNode
        :type k: int
        :rtype: List[int]
        """
        graph = collections.defaultdict(list)
        
        def dfs(node):
            if node.left:
                graph[node.val].append(node.left.val)
                graph[node.left.val].append(node.val)
                dfs(node.left)
            if node.right:
                graph[node.val].append(node.right.val)
                graph[node.right.val].append(node.val)
                dfs(node.right)
        
        dfs(root)
        visited = set()
        q = collections.deque()
        q.append((target.val,0))
        res = []
        while q:
            size = len(q)
            while size>0:
                node, dist = q.popleft()
                if dist == k:
                    res.append(node)
                if node in visited:
                    continue
                visited.add(node)
                for nextNode in graph[node]:
                    if nextNode not in visited:
                        q.append((nextNode, dist+1))
                size-=1
                
        return res
        

效果：
Runtime: 32 ms, faster than 78.31% of Python online submissions for All Nodes Distance K in Binary Tree.
Memory Usage: 14 MB, less than 29.91% of Python online submissions for All Nodes Distance K in Binary Tree.

reference:
https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/discuss/2297899/Python-or-BFS-or-Graph


"""
--------------------------------------题目分割线----------------------------------------------
"""
226. Invert Binary Tree <easy>
输入：
TreeNode
输出：
TreeNode

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def invertTree(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        def dfs(node):
            if not node:
                return
            
            node.left, node.right = node.right, node.left
            if node.left:
                dfs(node.left)
            if node.right:
                dfs(node.right)
        dfs(root)
        
        return root
                
        

效果：
Runtime: 23 ms, faster than 79.10% of Python online submissions for Invert Binary Tree.
Memory Usage: 13.4 MB, less than 73.49% of Python online submissions for Invert Binary Tree.





"""
--------------------------------------题目分割线----------------------------------------------
"""
210. Course Schedule II <medium>
输入：
int
int[int[]]
输出：
int[]

class Solution(object):
    def findOrder(self, numCourses, prerequisites):
        """
        :type numCourses: int
        :type prerequisites: List[List[int]]
        :rtype: List[int]
        """
        visited = [0]*numCourses
        graph = collections.defaultdict(list)
        # courses[0]:之后上的课
        # courses[1]:先修课
        # graph-> graph[先修课]=之后上的课[]
        # visited-> 尚未访问的后续课程
        for courses in prerequisites:
            graph[courses[1]].append(courses[0])
            visited[courses[0]]+=1
        
        # 一层一层拆，如果一门课从来没有出现在后续的选修课中，这门课必须要先选
        q = collections.deque()
        for i in range(len(visited)):
            if visited[i]==0:
                q.append(i)
            
        res = []
        
        while q:
            size = len(q)
            while size>0:
                foreCourse=q.popleft()
                res.append(foreCourse)
                for nextCourse in graph[foreCourse]:
                    visited[nextCourse]-=1
                    if visited[nextCourse]==0:
                        q.append(nextCourse)
                size-=1
        return res if len(res)==numCourses else []
        

效果：
Runtime: 174 ms, faster than 42.92% of Python online submissions for Course Schedule II.
Memory Usage: 14.8 MB, less than 91.77% of Python online submissions for Course Schedule II.

reference:
https://leetcode.com/problems/course-schedule-ii/discuss/2467417/python-solution-using-topological-sort-bfs-approach



"""
--------------------------------------题目分割线----------------------------------------------
"""

输入：

输出：



        

效果：





"""
--------------------------------------题目分割线----------------------------------------------
"""

输入：

输出：



        

效果：






"""
--------------------------------------题目分割线----------------------------------------------
"""

输入：

输出：



        

效果：





"""
--------------------------------------题目分割线----------------------------------------------
"""

输入：

输出：



        

效果：





"""
--------------------------------------题目分割线----------------------------------------------
"""

输入：

输出：



        

效果：
















