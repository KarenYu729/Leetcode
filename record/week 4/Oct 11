week 4
Oct 11


又回到了熟悉的图论的领域


"""
--------------------------------------题目分割线----------------------------------------------
"""
997. Find the Town Judge <easy>
输入：
int[int[]]
输出：
int

"""
***********************解法一分割线***********************
"""
class Solution(object):
    def findJudge(self, n, trust):
        """
        :type n: int
        :type trust: List[List[int]]
        :rtype: int
        """
        
        trustList = defaultdict(list)
        visited = [1]*(n+1)
        visited[0] = 0
        for a, b in trust:
            trustList[a].append(b)
        if len(trustList)!=n-1:
            return -1
        for i in trustList:
            for j in range(1,n+1):
                if j not in trustList[i]:
                    visited[j] = 0
        
        if 1 not in visited:
            return -1
        for i in range(1, len(visited)):
            if visited[i] == 1 and 1 not in visited[i+1:len(visited)]:
                return i
        
        return -1

效果：
Runtime: 2617 ms, faster than 5.01% of Python online submissions for Find the Town Judge.
Memory Usage: 18.6 MB, less than 62.17% of Python online submissions for Find the Town Judge.


"""
***********************解法二分割线***********************
"""
看一下别人的写法
class Solution(object):
    def findJudge(self, n, trust):
        """
        :type n: int
        :type trust: List[List[int]]
        :rtype: int
        """
        
        Trusted = [0] * (n+1)
        for (a, b) in trust:
            Trusted[a] -= 1
            Trusted[b] += 1
            
        for i in range(1, len(Trusted)):
            if Trusted[i] == n-1:
                return i
        return -1


效果：
Runtime: 791 ms, faster than 77.25% of Python online submissions for Find the Town Judge.
Memory Usage: 18.5 MB, less than 62.17% of Python online submissions for Find the Town Judge.




"""
--------------------------------------题目分割线----------------------------------------------
"""
841. Keys and Rooms <medium>
输入：
int[int[]]
输出：
bool

这里要注意一个问题，这是个有向图，我一开始用邻接矩阵做，然后发现一个问题，即使是所有房间的钥匙都能在其他房间找到（不存在想要进入这个房间必须进入这个房间）
但是也会出现，想进入A先进入B，想进入B先进入A的情况
如：
[[4],[3],[],[2,5,7],[1],[],[8,9],[],[],[6]]

class Solution(object):
    def canVisitAllRooms(self, rooms):
        """
        :type rooms: List[List[int]]
        :rtype: bool
        """
        q = deque(rooms[0])   #deque -> doubly ended queue
        visited = defaultdict(int)
        visited[0]=1
        count = 1  #to keep a count of unique number of rooms visited
        while q:
            room = q.popleft()  #poping first element
            if room not in visited:
                visited[room] = 1
                count+=1
                q+=rooms[room]
        if count==len(rooms):
            return True
        return False

效果：
Runtime: 110 ms, faster than 20.17% of Python online submissions for Keys and Rooms.
Memory Usage: 14 MB, less than 57.10% of Python online submissions for Keys and Rooms.


一点说明：
visited = defaultdict(int)
defaultdict接受一个工厂函数作为参数，如下来构造：

dict =defaultdict( factory_function)
这个factory_function可以是list、set、str等等，作用是当key不存在时，返回的是工厂函数的默认值，比如list对应[ ]，str对应的是空字符串，set对应set( )，int对应0，如下举例：

from collections import defaultdict
 
dict1 = defaultdict(int)
dict2 = defaultdict(set)
dict3 = defaultdict(str)
dict4 = defaultdict(list)
dict1[2] ='two'
 
print(dict1[1])
print(dict2[1])
print(dict3[1])
print(dict4[1])
 
 
输出：
0
set()
 
[]
 
————————————————
版权声明：本文为CSDN博主「《一夜飘零》」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/jiaxinhong/article/details/108398099


"""
--------------------------------------题目分割线----------------------------------------------
"""
841. Keys and Rooms <medium>
输入：
str
输出：
str

class Solution(object):
    def frequencySort(self, s):
        """
        :type s: str
        :rtype: str
        """
        # Count the occurence on each character
        cnt = collections.Counter(s)

        # Build string
        res = []
        for k, v in cnt.most_common():
            res += [k] * v
        return "".join(res)

效果：
Runtime: 160 ms, faster than 28.65% of Python online submissions for Sort Characters By Frequency.
Memory Usage: 17 MB, less than 41.26% of Python online submissions for Sort Characters By Frequency.


一点说明：
cnt = collections.Counter(s)
哈希表在python中可以用collections.Counter计数来体现。
该方法用于统计某序列中每个元素出现的次数，以键值对的方式存在字典中。但类型其实是Counter。

nums = [1, 2, 3, 1, 2, 1]
counts = collections.Counter(nums)
print(counts)
## Counter({1: 3, 2: 2, 3: 1})
1
2
3
4
凭借这个结构，可以计算出某个序列中出现次数最多的某个元素。也即在得到了counts之后求max即可。但这个max需要给依据索引。

print(max(counts)) # 3，这里只是求得最大的键值
print(max(counts.keys(), key=counts.get)) # 1，这里是按照key方法求最大
1
2
这里max是两个参数，前一个代表要max的是什么，也就是要返回最大键，后面的key代表要返回的最大的依据是什么，默认是本身，但这里给了key方法，count.get也就是求值，所以该方法就是说返回一个最大键，但这个最大的依据是值。如果某个键值对的值是最大的，那就返回其键。
————————————————
版权声明：本文为CSDN博主「Wayback_」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/m0_47105444/article/details/113867636

cnt.most_common()
Counter(a)   计算a中每个元素的数量，按数量从大到小输出

import numpy as np
from collections import Counter
 
a = [2,3,1,5,4,1,1,2]
a = np.array(a)
print(Counter(a))
 
 
结果Counter({1: 3, 2: 2, 3: 1, 5: 1, 4: 1})
可以看出元素1的数量最多，有3个
 

Counter(a).most_common(1)

经过Counter()方法排列后，获取数量最多的元素及准确数量，如果most_common()的参数是2，则获取数量排在前两位的元素及具体数量

print(Counter(a).most_common(1))
结果 [(1, 3)]
print(Counter(a).most_common(2))
结果 [(1, 3), (2, 2)]
 
print(Counter(a).most_common(2)[0])#得到元素个数最多的元素及个数
输出 (1, 3)
print(Counter(a).most_common(2)[0][0])#得到元素个数最多的元素
输出 1

————————————————
版权声明：本文为CSDN博主「LiChuanxiu」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/LiChuanxiu/article/details/103479656
