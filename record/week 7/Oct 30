week 7
Oct 30




先表达一下对火老师的感谢，如果不是上次看火老师倒洗衣液也不会
虽然十三号病院有这道题，但是我看广告跳过了

"""
--------------------------------------题目分割线----------------------------------------------
"""
365. Water and Jug Problem <medium>
输入：
int
int
int
输出：
bool

"""
***********************解法一分割线***********************
"""
class Solution(object):
    def canMeasureWater(self, jug1Capacity, jug2Capacity, targetCapacity):
        """
        :type jug1Capacity: int
        :type jug2Capacity: int
        :type targetCapacity: int
        :rtype: bool
        """
        if jug1Capacity + jug2Capacity < targetCapacity:
            return False
        def greatestCommonDevisor(x, y):
            while(y):
                x, y = y, x % y
            return x
        
        gcd = greatestCommonDevisor(jug1Capacity, jug2Capacity)
        return True if targetCapacity % gcd == 0 else False
           

效果：
Runtime: 27 ms, faster than 81.71% of Python online submissions for Water and Jug Problem.
Memory Usage: 13.3 MB, less than 89.02% of Python online submissions for Water and Jug Problem.

reference：
https://leetcode.com/problems/water-and-jug-problem/discuss/2542021/Python-oror-Greatest-Common-Devisor-oror-100-fast


"""
***********************解法二分割线***********************
"""

class Solution(object):
    def canMeasureWater(self, jug1Capacity, jug2Capacity, targetCapacity):
        """
        :type jug1Capacity: int
        :type jug2Capacity: int
        :type targetCapacity: int
        :rtype: bool
        """
        edges=[jug1Capacity,jug2Capacity,abs(jug2Capacity-jug1Capacity)]
        lst=[0]
        mx=max(jug1Capacity,jug2Capacity,targetCapacity)
        visited=[0]*1000001
        if targetCapacity>(jug1Capacity+jug2Capacity):
            return False
        visited[0]=1
        while lst:
            x=lst.pop(0)
            if x==targetCapacity:
                return True
            for i in edges:
                if x+i<=mx and visited[x+i]==0:
                    lst.append(x+i)
                    visited[x+i]=1
                if x-i>=0 and visited[x-i]==0:
                    lst.append(x-i)
                    visited[x-i]=1
        return False        

效果：
Runtime: 552 ms, faster than 53.66% of Python online submissions for Water and Jug Problem.
Memory Usage: 21.2 MB, less than 56.10% of Python online submissions for Water and Jug Problem.


reference：
https://leetcode.com/problems/water-and-jug-problem/discuss/2733181/Python-Solution-using-BFS-traversal



"""
--------------------------------------题目分割线----------------------------------------------
"""

输入：

输出：



        

效果：





"""
--------------------------------------题目分割线----------------------------------------------
"""

输入：

输出：



        

效果：






"""
--------------------------------------题目分割线----------------------------------------------
"""

输入：

输出：



        

效果：






"""
--------------------------------------题目分割线----------------------------------------------
"""

输入：

输出：



        

效果：





"""
--------------------------------------题目分割线----------------------------------------------
"""

输入：

输出：



        

效果：





"""
--------------------------------------题目分割线----------------------------------------------
"""

输入：

输出：



        

效果：






"""
--------------------------------------题目分割线----------------------------------------------
"""

输入：

输出：



        

效果：





"""
--------------------------------------题目分割线----------------------------------------------
"""

输入：

输出：



        

效果：




"""
--------------------------------------题目分割线----------------------------------------------
"""

输入：

输出：



        

效果：






"""
--------------------------------------题目分割线----------------------------------------------
"""

输入：

输出：



        

效果：





"""
--------------------------------------题目分割线----------------------------------------------
"""

输入：

输出：



        

效果：







