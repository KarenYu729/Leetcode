week 7
Oct 30




先表达一下对火老师的感谢，如果不是上次看火老师倒洗衣液也不会
虽然十三号病院有这道题，但是我看广告跳过了

"""
--------------------------------------题目分割线----------------------------------------------
"""
365. Water and Jug Problem <medium>
输入：
int
int
int
输出：
bool

"""
***********************解法一分割线***********************
"""
class Solution(object):
    def canMeasureWater(self, jug1Capacity, jug2Capacity, targetCapacity):
        """
        :type jug1Capacity: int
        :type jug2Capacity: int
        :type targetCapacity: int
        :rtype: bool
        """
        if jug1Capacity + jug2Capacity < targetCapacity:
            return False
        def greatestCommonDevisor(x, y):
            while(y):
                x, y = y, x % y
            return x
        
        gcd = greatestCommonDevisor(jug1Capacity, jug2Capacity)
        return True if targetCapacity % gcd == 0 else False
           

效果：
Runtime: 27 ms, faster than 81.71% of Python online submissions for Water and Jug Problem.
Memory Usage: 13.3 MB, less than 89.02% of Python online submissions for Water and Jug Problem.

reference：
https://leetcode.com/problems/water-and-jug-problem/discuss/2542021/Python-oror-Greatest-Common-Devisor-oror-100-fast


"""
***********************解法二分割线***********************
"""

class Solution(object):
    def canMeasureWater(self, jug1Capacity, jug2Capacity, targetCapacity):
        """
        :type jug1Capacity: int
        :type jug2Capacity: int
        :type targetCapacity: int
        :rtype: bool
        """
        edges=[jug1Capacity,jug2Capacity,abs(jug2Capacity-jug1Capacity)]
        lst=[0]
        mx=max(jug1Capacity,jug2Capacity,targetCapacity)
        visited=[0]*1000001
        if targetCapacity>(jug1Capacity+jug2Capacity):
            return False
        visited[0]=1
        while lst:
            x=lst.pop(0)
            if x==targetCapacity:
                return True
            for i in edges:
                if x+i<=mx and visited[x+i]==0:
                    lst.append(x+i)
                    visited[x+i]=1
                if x-i>=0 and visited[x-i]==0:
                    lst.append(x-i)
                    visited[x-i]=1
        return False        

效果：
Runtime: 552 ms, faster than 53.66% of Python online submissions for Water and Jug Problem.
Memory Usage: 21.2 MB, less than 56.10% of Python online submissions for Water and Jug Problem.


reference：
https://leetcode.com/problems/water-and-jug-problem/discuss/2733181/Python-Solution-using-BFS-traversal



"""
--------------------------------------题目分割线----------------------------------------------
"""
116. Populating Next Right Pointers in Each Node <medium>
输入：
Node
输出：
Node

"""
# Definition for a Node.
class Node(object):
    def __init__(self, val=0, left=None, right=None, next=None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
"""

class Solution(object):
    def connect(self, root):
        """
        :type root: Node
        :rtype: Node
        """
        if root is None:
            return root
        
        q = collections.deque([(1, root)])
        pre_level, pre_node = 0, None
        
        while q:
            level, node = q.popleft()
            if level == pre_level:  # current node is not the first node of level
                pre_node.next = node
                pre_node = node
            else:  # pre_level < level and node is the first node of level, then no need to update pre_node.next, 
                # leave it as None, update pre_node = node only.
                pre_level, pre_node = level, node
            if node.left:  # root is a perfect binary tree, once left exists, right must also exist
                q.append((level + 1, node.left))
                q.append((level + 1, node.right))
        return root
                
效果：
Runtime: 52 ms, faster than 87.50% of Python online submissions for Populating Next Right Pointers in Each Node.
Memory Usage: 16.7 MB, less than 6.17% of Python online submissions for Populating Next Right Pointers in Each Node.

reference:
https://leetcode.com/problems/populating-next-right-pointers-in-each-node/discuss/1654101/Python-Two-Solutions-oror-BFS-and-DFS-oror-Image-Explanation-oror-Beginner-Friendly



"""
--------------------------------------题目分割线----------------------------------------------
"""

输入：

输出：



        

效果：






"""
--------------------------------------题目分割线----------------------------------------------
"""

输入：

输出：



        

效果：






"""
--------------------------------------题目分割线----------------------------------------------
"""

输入：

输出：



        

效果：





"""
--------------------------------------题目分割线----------------------------------------------
"""

输入：

输出：



        

效果：





"""
--------------------------------------题目分割线----------------------------------------------
"""

输入：

输出：



        

效果：






"""
--------------------------------------题目分割线----------------------------------------------
"""

输入：

输出：



        

效果：





"""
--------------------------------------题目分割线----------------------------------------------
"""

输入：

输出：



        

效果：




"""
--------------------------------------题目分割线----------------------------------------------
"""

输入：

输出：



        

效果：






"""
--------------------------------------题目分割线----------------------------------------------
"""

输入：

输出：



        

效果：





"""
--------------------------------------题目分割线----------------------------------------------
"""

输入：

输出：



        

效果：







